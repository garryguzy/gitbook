{"version":3,"sources":["../../../src/output/modifiers/annotateText.js"],"names":["escape","require","ANNOTATION_IGNORE","pregQuote","str","replace","replaceText","$","el","search","text_only","each","node","firstChild","val","new_val","remove","nodeType","nodeValue","test","before","push","nextSibling","length","annotateText","entries","glossaryFilePath","forEach","entry","entryId","getID","name","getName","description","getDescription","searchRegex","RegExp","toLowerCase","$this","is","parents","match","module","exports"],"mappings":";;AAAA,IAAMA,SAASC,QAAQ,aAAR,CAAf;;AAEA;AACA,IAAMC,oBAAoB,kDAA1B;;AAEA,SAASC,SAAT,CAAmBC,GAAnB,EAAwB;AACpB,WAAO,CAACA,MAAM,EAAP,EAAWC,OAAX,CAAmB,6CAAnB,EAAkE,MAAlE,CAAP;AACH;;AAED,SAASC,WAAT,CAAqBC,CAArB,EAAwBC,EAAxB,EAA4BC,MAA5B,EAAoCJ,OAApC,EAA6CK,SAA7C,EAAwD;AACpD,WAAOH,EAAEC,EAAF,EAAMG,IAAN,CAAW,YAAW;AACzB,YAAIC,OAAO,KAAKC,UAAhB;AAAA,YAA4BC,YAA5B;AAAA,YAAiCC,gBAAjC;AACA;AACA,YAAMC,SAAS,EAAf;;AAEA;AACA,YAAIJ,IAAJ,EAAU;;AAEN;AACA,mBAAOA,IAAP,EAAa;;AAET;AACA,oBAAIA,KAAKK,QAAL,KAAkB,CAAtB,EAAyB;;AAErB;AACAH,0BAAMF,KAAKM,SAAX;;AAEA;AACAH,8BAAUD,IAAIT,OAAJ,CAAYI,MAAZ,EAAoBJ,OAApB,CAAV;;AAEA;AACA,wBAAIU,YAAYD,GAAhB,EAAqB;;AAEjB,4BAAI,CAACJ,SAAD,IAAc,IAAIS,IAAJ,CAASJ,OAAT,CAAlB,EAAqC;AACjC;AACA;AACAR,8BAAEK,IAAF,EAAQQ,MAAR,CAAeL,OAAf;;AAEA;AACAC,mCAAOK,IAAP,CAAYT,IAAZ;AACH,yBAPD,MAOO;AACH;AACA;AACAA,iCAAKM,SAAL,GAAiBH,OAAjB;AACH;AACJ;AACJ;;AAEDH,uBAAOA,KAAKU,WAAZ;AACH;AACJ;;AAED;AACA,YAAIN,OAAOO,MAAX,EAAmBhB,EAAES,MAAF,EAAUA,MAAV;AACtB,KA5CM,CAAP;AA6CH;;AAED;;;;;;;AAOA,SAASQ,YAAT,CAAsBC,OAAtB,EAA+BC,gBAA/B,EAAiDnB,CAAjD,EAAoD;AAChDkB,YAAQE,OAAR,CAAgB,UAACC,KAAD,EAAW;AACvB,YAAMC,UAAcD,MAAME,KAAN,EAApB;AACA,YAAMC,OAAcH,MAAMI,OAAN,EAApB;AACA,YAAMC,cAAcL,MAAMM,cAAN,EAApB;AACA,YAAMC,cAAc,IAAIC,MAAJ,CAAW,SAASjC,UAAU4B,KAAKM,WAAL,EAAV,CAAT,GAAyC,MAApD,EAA6D,IAA7D,CAApB;;AAEA9B,UAAE,GAAF,EAAOI,IAAP,CAAY,YAAW;AACnB,gBAAM2B,QAAQ/B,EAAE,IAAF,CAAd;;AAEA,gBACI+B,MAAMC,EAAN,CAASrC,iBAAT,KACAoC,MAAME,OAAN,CAActC,iBAAd,EAAiCqB,MAAjC,GAA0C,CAF9C,EAGE;;AAEFjB,wBAAYC,CAAZ,EAAe,IAAf,EAAqB4B,WAArB,EAAkC,UAACM,KAAD,EAAW;AACzC,uBAAO,eAAef,gBAAf,GAAkC,GAAlC,GAAwCG,OAAxC,GAAkD,IAAlD,GACD,+BADC,GACiC7B,OAAOiC,WAAP,CADjC,GACuD,IADvD,GAEDQ,KAFC,GAGD,MAHN;AAIH,aALD;AAMH,SAdD;AAgBH,KAtBD;AAuBH;;AAEDC,OAAOC,OAAP,GAAiBnB,YAAjB","file":"annotateText.js","sourcesContent":["const escape = require('escape-html');\n\n// Selector to ignore\nconst ANNOTATION_IGNORE = '.no-glossary,code,pre,a,script,h1,h2,h3,h4,h5,h6';\n\nfunction pregQuote(str) {\n    return (str + '').replace(/([\\\\\\.\\+\\*\\?\\[\\^\\]\\$\\(\\)\\{\\}\\=\\!\\<\\>\\|\\:])/g, '\\\\$1');\n}\n\nfunction replaceText($, el, search, replace, text_only) {\n    return $(el).each(function() {\n        let node = this.firstChild, val, new_val;\n        // Elements to be removed at the end.\n        const remove = [];\n\n        // Only continue if firstChild exists.\n        if (node) {\n\n            // Loop over all childNodes.\n            while (node) {\n\n                // Only process text nodes.\n                if (node.nodeType === 3) {\n\n                    // The original node value.\n                    val = node.nodeValue;\n\n                    // The new value.\n                    new_val = val.replace(search, replace);\n\n                    // Only replace text if the new value is actually different!\n                    if (new_val !== val) {\n\n                        if (!text_only && /</.test(new_val)) {\n                            // The new value contains HTML, set it in a slower but far more\n                            // robust way.\n                            $(node).before(new_val);\n\n                            // Don't remove the node yet, or the loop will lose its place.\n                            remove.push(node);\n                        } else {\n                            // The new value contains no HTML, so it can be set in this\n                            // very fast, simple way.\n                            node.nodeValue = new_val;\n                        }\n                    }\n                }\n\n                node = node.nextSibling;\n            }\n        }\n\n        // Time to remove those elements!\n        if (remove.length) $(remove).remove();\n    });\n}\n\n/**\n * Annotate text using a list of GlossaryEntry\n *\n * @param {List<GlossaryEntry>}\n * @param {String} glossaryFilePath\n * @param {HTMLDom} $\n */\nfunction annotateText(entries, glossaryFilePath, $) {\n    entries.forEach((entry) => {\n        const entryId     = entry.getID();\n        const name        = entry.getName();\n        const description = entry.getDescription();\n        const searchRegex = new RegExp('\\\\b(' + pregQuote(name.toLowerCase()) + ')\\\\b' , 'gi');\n\n        $('*').each(function() {\n            const $this = $(this);\n\n            if (\n                $this.is(ANNOTATION_IGNORE) ||\n                $this.parents(ANNOTATION_IGNORE).length > 0\n            ) return;\n\n            replaceText($, this, searchRegex, (match) => {\n                return '<a href=\"/' + glossaryFilePath + '#' + entryId + '\" '\n                    + 'class=\"glossary-term\" title=\"' + escape(description) + '\">'\n                    + match\n                    + '</a>';\n            });\n        });\n\n    });\n}\n\nmodule.exports = annotateText;\n"]}