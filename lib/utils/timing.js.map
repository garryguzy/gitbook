{"version":3,"sources":["../../src/utils/timing.js"],"names":["Immutable","require","is","Promise","timers","startDate","Date","now","measure","type","p","count","total","min","undefined","max","start","after","end","duration","Math","isPromise","fin","result","time","ms","toFixed","dump","logger","prefix","measured","totalDuration","logLevel","getLevel","setLevel","Map","valueSeq","sortBy","timer","forEach","percent","debug","ln","module","exports"],"mappings":"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","file":"timing.js","sourcesContent":["const Immutable = require('immutable');\nconst is = require('is');\nconst Promise = require('./promise');\n\nconst timers = {};\nconst startDate = Date.now();\n\n/**\n * Mesure an operation\n *\n * @param {String} type\n * @param {Promise|Function} p\n * @return {Promise|Mixed} result\n */\nfunction measure(type, p) {\n    timers[type] = timers[type] || {\n        type,\n        count: 0,\n        total: 0,\n        min: undefined,\n        max: 0\n    };\n\n    const start = Date.now();\n\n    const after = () => {\n        const end = Date.now();\n        const duration = (end - start);\n\n        timers[type].count ++;\n        timers[type].total += duration;\n\n        if (is.undefined(timers[type].min)) {\n            timers[type].min = duration;\n        } else {\n            timers[type].min = Math.min(timers[type].min, duration);\n        }\n\n        timers[type].max = Math.max(timers[type].max, duration);\n    };\n\n    if (Promise.isPromise(p)) {\n        return p.fin(after);\n    }\n\n    const result = p();\n    after();\n\n    return result;\n}\n\n/**\n * Return a milliseconds number as a second string\n *\n * @param {Number} ms\n * @return {String}\n */\nfunction time(ms) {\n    if (ms < 1000) {\n        return (ms.toFixed(0)) + 'ms';\n    }\n\n    return (ms / 1000).toFixed(2) + 's';\n}\n\n/**\n * Dump all timers to a logger\n * @param {Logger} logger\n */\nfunction dump(logger) {\n    const prefix = '    > ';\n    let measured = 0;\n    const totalDuration = Date.now() - startDate;\n\n    // Enable debug logging\n    const logLevel = logger.getLevel();\n    logger.setLevel('debug');\n\n    Immutable.Map(timers)\n        .valueSeq()\n        .sortBy((timer) => {\n            measured += timer.total;\n            return timer.total;\n        })\n        .forEach((timer) => {\n            const percent = (timer.total * 100) / totalDuration;\n\n            logger.debug.ln((percent.toFixed(1)) + '% of time spent in \"' + timer.type + '\" (' + timer.count + ' times) :');\n            logger.debug.ln(prefix + 'Total: ' + time(timer.total) + ' | Average: ' + time(timer.total / timer.count));\n            logger.debug.ln(prefix + 'Min: ' + time(timer.min) + ' | Max: ' + time(timer.max));\n            logger.debug.ln('---------------------------');\n        });\n\n\n    logger.debug.ln(time(totalDuration - measured) + ' spent in non-mesured sections');\n\n    // Rollback to previous level\n    logger.setLevel(logLevel);\n}\n\nmodule.exports = {\n    measure,\n    dump\n};\n"]}