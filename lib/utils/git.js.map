{"version":3,"sources":["../../src/utils/git.js"],"names":["is","require","path","crc","URI","pathUtil","Promise","command","fs","GIT_PREFIX","Git","tmpDir","cloned","host","ref","crc32","toString","that","then","dir","allocateDir","repoId","repoID","repoPath","join","exec","cwd","thenResolve","giturl","isUrl","resolveRoot","string","parseUrl","clone","repo","resolve","filepath","isInRoot","relativeToGit","relative","split","sep","indexOf","slice","length","uri","fragment","fileParts","module","exports"],"mappings":"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","file":"git.js","sourcesContent":["const is = require('is');\nconst path = require('path');\nconst crc = require('crc');\nconst URI = require('urijs');\n\nconst pathUtil = require('./path');\nconst Promise = require('./promise');\nconst command = require('./command');\nconst fs = require('./fs');\n\nconst GIT_PREFIX = 'git+';\n\nclass Git {\n    constructor() {\n        this.tmpDir = null;\n        this.cloned = {};\n    }\n\n    // Return an unique ID for a combinaison host/ref\n    repoID(host, ref) {\n        return crc.crc32(host + '#' + (ref || '')).toString(16);\n    }\n\n    // Allocate a temporary folder for cloning repos in it\n    allocateDir() {\n        const that = this;\n\n        if (this.tmpDir) {\n            return Promise();\n        }\n\n        return fs.tmpDir()\n        .then((dir) => {\n            that.tmpDir = dir;\n        });\n    }\n\n    /**\n     * Clone a git repository if non existant\n     * @param {String} host: url of the git repository\n     * @param {String} ref: branch/commit/tag to checkout\n     * @return {Promise<String>} repoPath\n     */\n    clone(host, ref) {\n        const that = this;\n\n        return this.allocateDir()\n\n        // Return or clone the git repo\n        .then(() => {\n            // Unique ID for repo/ref combinaison\n            const repoId = that.repoID(host, ref);\n\n            // Absolute path to the folder\n            const repoPath = path.join(that.tmpDir, repoId);\n\n            if (that.cloned[repoId]) return repoPath;\n\n            // Clone repo\n            return command.exec('git clone ' + host + ' ' + repoPath)\n\n            // Checkout reference if specified\n            .then(() => {\n                that.cloned[repoId] = true;\n\n                if (!ref) return;\n                return command.exec('git checkout ' + ref, { cwd: repoPath });\n            })\n            .thenResolve(repoPath);\n        });\n    }\n\n    /**\n     * Resole a git url, clone the repo and return the path to the right file.\n     * @param {String} giturl\n     * @return {Promise<String>} filePath\n     */\n    resolve(giturl) {\n        // Path to a file in a git repo?\n        if (!Git.isUrl(giturl)) {\n            if (this.resolveRoot(giturl)) return Promise(giturl);\n            return Promise(null);\n        }\n        if (is.string(giturl)) giturl = Git.parseUrl(giturl);\n        if (!giturl) return Promise(null);\n\n        // Clone or get from cache\n        return this.clone(giturl.host, giturl.ref)\n        .then((repo) => {\n            return path.resolve(repo, giturl.filepath);\n        });\n    }\n\n    /**\n     * Return root of git repo from a filepath\n     * @param  {String} filePath\n     * @return {String} repoPath\n     */\n    resolveRoot(filepath) {\n        // No git repo cloned, or file is not in a git repository\n        if (!this.tmpDir || !pathUtil.isInRoot(this.tmpDir, filepath)) return null;\n\n        // Extract first directory (is the repo id)\n        const relativeToGit = path.relative(this.tmpDir, filepath);\n        const repoId = relativeToGit.split(path.sep)[0];\n\n        if (!repoId) {\n            return;\n        }\n\n        // Return an absolute file\n        return path.resolve(this.tmpDir, repoId);\n    }\n\n    /**\n     * Check if an url is a git dependency url\n     * @param  {String} giturl\n     * @return {Boolean} isUrl\n     */\n    static isUrl(giturl) {\n        return (giturl.indexOf(GIT_PREFIX) === 0);\n    }\n\n    /**\n     * Parse and extract infos\n     * @param  {String} giturl\n     * @return {Object} { host, ref, filepath }\n     */\n    static parseUrl(giturl) {\n        if (!Git.isUrl(giturl)) {\n            return null;\n        }\n        giturl = giturl.slice(GIT_PREFIX.length);\n\n        const uri = new URI(giturl);\n        const ref = uri.fragment() || null;\n        uri.fragment(null);\n\n        // Extract file inside the repo (after the .git)\n        const fileParts = uri.path().split('.git');\n        let filepath = fileParts.length > 1 ? fileParts.slice(1).join('.git') : '';\n        if (filepath[0] == '/') {\n            filepath = filepath.slice(1);\n        }\n\n        // Recreate pathname without the real filename\n        uri.path(fileParts[0] + '.git');\n\n        return {\n            host: uri.toString(),\n            ref,\n            filepath\n        };\n    }\n\n}\n\nmodule.exports = Git;\n"]}