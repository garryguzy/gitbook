{"version":3,"sources":["../../src/models/glossary.js"],"names":["require","Record","OrderedMap","File","GlossaryEntry","DEFAULTS","file","entries","Glossary","get","merge","name","id","nameToID","entry","getID","set","description","addEntry","map","module","exports"],"mappings":";;;;;;;;;;eAA+BA,QAAQ,WAAR,C;IAAvBC,M,YAAAA,M;IAAQC,U,YAAAA,U;;AAEhB,IAAMC,OAAOH,QAAQ,QAAR,CAAb;AACA,IAAMI,gBAAgBJ,QAAQ,iBAAR,CAAtB;;AAEA,IAAMK,WAAW;AACbC,UAAS,IAAIH,IAAJ,EADI;AAEbI,aAASL;AAFI,CAAjB;;IAKMM,Q;;;;;;;;;;;kCACQ;AACN,mBAAO,KAAKC,GAAL,CAAS,MAAT,CAAP;AACH;;;qCAEY;AACT,mBAAO,KAAKA,GAAL,CAAS,SAAT,CAAP;AACH;;AAED;;;;;;;;gCAKQH,I,EAAM;AACV,mBAAO,KAAKI,KAAL,CAAW,EAAEJ,UAAF,EAAX,CAAP;AACH;;AAED;;;;;;;;iCAKSK,I,EAAM;AAAA,gBACHJ,OADG,GACS,IADT,CACHA,OADG;;AAEX,gBAAMK,KAAKR,cAAcS,QAAd,CAAuBF,IAAvB,CAAX;;AAEA,mBAAOJ,QAAQE,GAAR,CAAYG,EAAZ,CAAP;AACH;;AAED;;;;;;;;iCAKSE,K,EAAO;AACZ,gBAAMF,KAAKE,MAAMC,KAAN,EAAX;AADY,gBAENR,OAFM,GAEM,IAFN,CAENA,OAFM;;;AAIZA,sBAAUA,QAAQS,GAAR,CAAYJ,EAAZ,EAAgBE,KAAhB,CAAV;AACA,mBAAO,KAAKE,GAAL,CAAS,SAAT,EAAoBT,OAApB,CAAP;AACH;;AAED;;;;;;;;uCAKeI,I,EAAMM,W,EAAa;AAC9B,gBAAMH,QAAQ,IAAIV,aAAJ,CAAkB;AAC5BO,0BAD4B;AAE5BM;AAF4B,aAAlB,CAAd;;AAKA,mBAAO,KAAKC,QAAL,CAAcJ,KAAd,CAAP;AACH;;AAED;;;;;;;;;0CAMyBP,O,EAAS;AAC9BA,sBAAUA,QAAQY,GAAR,CAAY,UAACL,KAAD,EAAW;AAC7B,oBAAI,EAAEA,iBAAiBV,aAAnB,CAAJ,EAAuC;AACnCU,4BAAQ,IAAIV,aAAJ,CAAkBU,KAAlB,CAAR;AACH;;AAED,uBAAO,CAACA,MAAMF,EAAP,EAAWE,KAAX,CAAP;AACH,aANS,CAAV;;AAQA,mBAAO,IAAIN,QAAJ,CAAa;AAChBD,yBAASL,WAAWK,OAAX;AADO,aAAb,CAAP;AAGH;;;;EA3EkBN,OAAOI,QAAP,C;;AA8EvBe,OAAOC,OAAP,GAAiBb,QAAjB","file":"glossary.js","sourcesContent":["const { Record, OrderedMap } = require('immutable');\n\nconst File = require('./file');\nconst GlossaryEntry = require('./glossaryEntry');\n\nconst DEFAULTS = {\n    file:    new File(),\n    entries: OrderedMap()\n};\n\nclass Glossary extends Record(DEFAULTS) {\n    getFile() {\n        return this.get('file');\n    }\n\n    getEntries() {\n        return this.get('entries');\n    }\n\n    /**\n     * Set file linked to the glossary.\n     * @param  {File} file\n     * @return {Readme}\n     */\n    setFile(file) {\n        return this.merge({ file });\n    }\n\n    /**\n     * Return an entry by its name.\n     * @param {String} name\n     * @return {GlossaryEntry}\n     */\n    getEntry(name) {\n        const { entries } = this;\n        const id = GlossaryEntry.nameToID(name);\n\n        return entries.get(id);\n    }\n\n    /**\n     * Add/Replace an entry to a glossary.\n     * @param {GlossaryEntry} entry\n     * @return {Glossary}\n     */\n    addEntry(entry) {\n        const id = entry.getID();\n        let { entries } = this;\n\n        entries = entries.set(id, entry);\n        return this.set('entries', entries);\n    }\n\n    /**\n     * Add/Replace an entry to a glossary by name/description.\n     * @param {GlossaryEntry} entry\n     * @return {Glossary}\n     */\n    addEntryByName(name, description) {\n        const entry = new GlossaryEntry({\n            name,\n            description\n        });\n\n        return this.addEntry(entry);\n    }\n\n    /**\n     * Create a glossary from a list of entries.\n     *\n     * @param {Array|List} entries\n     * @return {Glossary}\n     */\n    static createFromEntries(entries) {\n        entries = entries.map((entry) => {\n            if (!(entry instanceof GlossaryEntry)) {\n                entry = new GlossaryEntry(entry);\n            }\n\n            return [entry.id, entry];\n        });\n\n        return new Glossary({\n            entries: OrderedMap(entries)\n        });\n    }\n}\n\nmodule.exports = Glossary;\n"]}